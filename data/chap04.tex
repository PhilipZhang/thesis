
\chapter{基于图像树木轻量化建模的若干算法}
\label{cha:algorithm}
%----------------------------------PyrLK--------------------------------------
\section{基于改进的PyrLK光流法的特征点匹配方法}
\label{sec:pyrlk}

\subsection{对于SIFT特征点匹配的尝试}
对于特征点的匹配，本文首先尝试的是利用VisualSFM工具自带的SIFT特征点匹配。
但是经过大量实验发现，该工具自带的SIFT特征点匹配并不能很完整地找到匹配的
点对，从而导致了三维重建所依赖的数据不足、不精确，最后重建出来一个缺失度
很大的模型，这样的模型显然不能成功的进行骨架抽取。

根据实验结果分析，除开

\subsection{基于PyrLK光流法的特征点匹配}
\label{subsec:pyrlk}

\subsection{改进的PyrLK光流法}
\label{subsec:revisedpyrlk}

\subsection{基于改进PyrLK光流法的三维重建}

%---------------------------------三维重建-----------------------------------
%\section{基于体素泛洪与空间反向投影的三维重建}
%\label{sec:3drec}

%---------------------------------骨架抽取-----------------------------------
\section{基于三维体素泛洪与线性拟合的三维树木骨架抽取}
\label{sec:sklextract}
在获取了精确的点云模型之后，出于后续轻量化的考虑，需要将模型的存储方式由
密集的点云转化为逻辑的父子结构。用树形的数据结构来表达现实的树结构，这是很
自然的想法，相对于面片结构，树形结构也是一种更为轻量化的存储方式。每个节点表示
树枝的起点，存储着该节点的空间位置，半径和该节点的父子枝信息以及兄弟信息。一个
节点和它的一个子节点形成一个空间线段，若干空间线段组成一条连续的树枝。

本文从树的生长规律入手，从根节点往子节点生长。生长的依据则为当前节点所在邻域
内的空间点云分布，节点邻域大小由步长来控制，步长会探索式地递增，直到达到了增长的阈值，
邻域大小才确定下来。然后从其点云分布拟合出各个分支的方向，从而生长出新的子节点，
并递归地生长下去直到点云的边界。

\subsection{三维体素模型}
前面三维重建步骤得到的结果是一个点云模型，该模型中的点数量庞大，不适于后续的
邻域搜索，因此我们需要对点云进行体素化处理。所谓体素化，就是将点云占据的空间
划分成一个个的小立方体，每一个立方体称之为一个体素。

在将点云模型转化为体素模型以后，对于点云的邻域搜索便转化为了对于空间临近体素的
搜索，体素的位置就反映了点集的位置，因此不用每次搜索都遍历整个点云，而是只用将
步长范围体素中的点集遍历即可。由于体素是我们处理的基本单位，所以体素的大小也
直接决定了体素模型的精度，因此，在确保非空体素的空间连续性和效率允许的基础上，
本文建议让体素尽可能的小，以保证模型的精度。

图片。。。

伪代码。。。
\begin{algorithm}
	\caption{点云模型体素化}
\begin{algorithmic}[1]
	\Require 点云模型$M$
	\Require 体素维度$d$
	\Ensure 三维体素数组$\mathbb{V}[1..d,1..d,1..d]$
	\State 初始化点云边界值$X_{max}=Y_{max}=Z_{max}=MIN\uline\quad FLOAT,X_{min}=Y_{min}=Z_{min}=MAX\uline\quad FLOAT$
	\ForAll{空间点$P(P_x,P_y,P_z) \in M$}
		\State $CheckBoundary(P)$
	\EndFor
\ForAll{空间点$P(P_x,P_y,P_z) \in M$}
\State $V_x = \frac{P_x-X_{min}}{X_{max}-X_{min}}\cdot d$
\State $V_y = \frac{P_y-Y_{min}}{Y_{max}-Y_{min}}\cdot d$
\State $V_z = \frac{P_z-Z_{min}}{Z_{max}-Z_{min}}\cdot d$
\State $\mathbb{V}[V_x, V_y, V_z] = \mathbb{V}[V_x, V_y, V_z] \bigcup \{P\} $
	\EndFor
\end{algorithmic}
\end{algorithm}

\subsection{三维体素泛洪确定邻域范围}
在确定了三维体素模型以后，便需要从根到叶，自底向上地对树的骨架结构进行生长。
生长的依据是已经得到的体素模型，将体素模型中点的分布作用于骨架的分支，便可以
张成骨架模型。

具体方法是将根节点置为当前节点，对其进行三维泛洪，首先对其相邻的27个体素进行泛洪，若
体素不为空，则将其加入邻域范围，若为空，则停止向该方向进行迭代。同时将加入邻域
范围的体素置为无效，表示其已经参与了泛洪，不再参与骨架的重建，这样不仅可以对算法
的结束有一个很好的约束条件，同时也可以减少重复处理的次数，加快算法的完成。然后进行下一次迭代，
对新加入的体素进行27方向的泛洪，并把有效的体素加入到邻域范围。接着比较两次迭代
体素增加的比例，如果低于设置的阈值，则停止迭代，当前的邻域范围即为三维泛洪得到
的当前节点的邻域范围。

图片。。。

该算法的伪代码如下：\\

\begin{algorithm} \label{alg:3dfld}
	\caption{三维体素泛洪确定邻域范围}
	\begin{algorithmic}[1]
		\Require 当前体素$C$，三维体素数组$\mathbb{V}[1..d,1..d,1..d]$，
		泛洪方向数组$\mathbb{D}[1..27]$，邻域范围增长比例阈值$\lambda$
		%\Require 三维体素数组$\mathbb{V}[1..d,1..d,1..d]$
		%\Require 泛洪方向数组$\mathbb{D}[1..27]$
		%\Require 邻域范围增长比例阈值$\lambda$
		\Ensure	邻域范围内体素集合$\mathbb{S}$
		\State 初始化单次迭代新增体素集合$\mathbb{S'}$
		\State $\mathbb{S'}.AddVoxel($根节点所在体素$)$
		\ForAll{泛洪方向$Direction \in \mathbb{D}$}
			\State $NewIndex = C.Index + Direction$
			\State $NewVoxel = \mathbb{V}[NewIndex.x,NewIndex.y,NewIndex.z]$
			\If{$NewVoxel$非空$\bigcap NewVoxel$有效}
				\State $\mathbb{S'}.AddVoxel(NewVoxel)$
			\EndIf
		\EndFor
		\State 体素增长比例$\mu=\frac{\mathbb{S'}.VoxelCount}{\mathbb{S}.VoxelCount}$
		\If{$\mu > \lambda$}
			\ForAll{$voxel \in \mathbb{S'}$}
				\State 把$voxel$作为当前体素进行递归调用
			\EndFor
		\EndIf
		\State \Return $\mathbb{S}$
	\end{algorithmic}
\end{algorithm}

在进行三维泛洪的时候，可以编程实现27个方向迭代过程的并行化，以提高算法的效率。

\subsection{通过最小二乘法线性拟合确定分支}
当得到邻域范围以后，便得到了邻域内体素在基于当前节点27个方向上的密度分布，而
每个体素内又包含着若干的点，因此等于是得到了在当前节点邻域内的点云分布情况。
接下来的工作就是怎样从各个方向的点云的分布情况抽取出核心的骨架。本文应用线性
拟合的方法来从密集的点中抽取出一条线段，作为该部分的骨架。

该方法首先要剔除掉那些点云密度很小的方向，以免每个节点都朝各个方向长出一些
细碎的枝条。因为这些细碎的枝条就算在此步中不剔除，到后续的轻量化的时候也不容许
它们的存在。

然后对于剩下的若干方向$d_1,d_2...d_k$，每个方向都对应着树木的一个骨架。在处理
某个方向$d_i$时，将其包含的体素中的所有点抽取出来，得到一个密集的点集$S_i$。
然后采用待定方程的办法，设直线方程为：
\begin{equation}
	\mathbf{x} = \mathbf{x_0} + \mathbf{d}t,\quad(t \in [0,\infty))
\end{equation}

其中$\mathbf{x_0}$是当前节点的坐标，$\mathbf{d}$是待拟合的直线方向。我们假设
点集$S_i$中的点$P_1,P_2,...P_m$都在直线上，则可以得到以下方程组：\\

\begin{equation} \label{eq:line}
	\left\{ 
		\begin{array}{lll}
			a_{11}d_x+a_{12}d_y+a_{13}d_z & = & b1\\
			a_{21}d_x+a_{22}d_y+a_{23}d_z & = & b2\\
			... & & \\
			a_{n1}d_x+a_{n2}d_y+a_{n3}d_z & = & bn
		\end{array}
	\right.
\end{equation}

其中具体数值未给出，注意这里的$n=3m$，因为每个点$P$可以提供三个方向的方程式。
在这个方程组中，令\\
\begin{displaymath}
	\mathbf{U}=
\left(
\begin{array}{ccc}
	a_{11} & a_{12} & a_{13}\\
	a_{21} & a_{22} & a_{23}\\
	... & ... & ...\\
	a_{n1} & a_{n2} & a_{n3}\\
\end{array}
\right)
,\quad
\mathbf{d}=
\left(
\begin{array}{c}
	d_x\\
	d_y\\
	d_z
\end{array}
\right)
,\quad
\mathbf{b}=
\left(
\begin{array}{c}
	b_1\\
	b_2\\
	...\\
	b_n
\end{array}
\right)
\end{displaymath}


在实践中，由于筛选方向上的点数较多且发散分布，由线性代数的理论知，$\mathbf{U}$是过约束的，
即$n>r$,其中$r$是矩阵$\mathbf{U}$的秩。这种情况下没有标准的解，只能找到使误差最小的向量$\mathbf{d}$，
误差定义为:\\
\begin{equation}
	E\xlongequal{def} \sum_{i=1}^n(\mathbf{d}t_i - \mathbf{x_i} + \mathbf{x_0})^2=|\mathbf{Ud}-\mathbf{b}|^2
\end{equation}

由于$E$正比于方程的均方误差，因此只要E达到最小值，那么点集相对于该直线的波动就最
小。换句话说，也就是该直线最好的模拟了该点集所表示的骨架。由线性代数的方法很容易
可以解得$\mathbf{d}=\mathbf{[(U^TU)^{-1}U^T]b}$。

图片。。。

下表是得到邻域信息后进行骨架抽取的伪代码，其中\textit{Least Squares Processing}表示运用最小二乘法进行
线性拟合。

\begin{algorithm}
	\caption{基于邻域的骨架抽取}
	\begin{algorithmic}[1]
		\Require 当前节点体素$V$
		\Require 骨架方向数组$\mathbb{D}[1..n]$
		\Ensure 当前节点子节点集合$\mathbb{S}$
		\ForAll{骨架方向$d\in D$}
			\State $NewChild\gets Least Squares Processing$
			\State $\mathbb{S}.AddChild(NewChild)$
		\EndFor
		\State \Return $\mathbb{S}$
	\end{algorithmic}
\end{algorithm}

\subsection{半径怎么探索？？}
1. 用公式计算，线性，2次方等等。。。
2. 根据拟合出的直线，算其他点到该直线距离的平均值，加一个约束就是子枝半径不能超过父枝。

%---------------------------------轻量化-----------------------------------
\section{基于枝干合并的轻量化处理}
\label{sec:branchcombine}
用基于多方向迭代与步长探索得到的三维树木骨架通常是很细致和准确的，尽管它相对于
用3DSMAX等建模工具手工建模得到的面片模型已经大大的轻量化了。但是如果应用是用于
大规模的树木建模，那么我们有必要根据应用需求进一步进行轻量化处理。

\subsection{L-System的尝试}
\label{subsec:lsystem}

\subsubsection{L-System简介}
L-System是一种并行的重写系统和正规语法，
它的结构可以用可以定义为一个3元组:\\
\[\mathbf{M} = (V, \omega, P)\]
其中：\\
\begin{itemize}
	\item $\mathbf{V}$(字母表) 表示可以被替代的字符的集合。
	\item $\mathbf{\omega}$(初始串) 表示L-System的初始状态。
	\item $\mathbf{P}$(规则集合) 表示一系列的衍生规则。
\end{itemize}
L-System可以根据这三个组成部分的不同而递归地产生形态各异的字符串。
由于L-System具有递归生长的特性，因此我们可以用L-System规则来表达一个具有自相似形态
或者分形结构的物体，比如本文所研究的对象\raisebox{0.5mm}{------}树木。

\subsubsection{树木模型的参数化L-System规则抽取}
球面海龟几何的提出，用参数化的L-System规则描述了树木的结构信息。在球面海龟几何中，
节点的空间几何信息用4个量(长度$l$、半径$r$、父子枝夹角$\theta$和水平转角$\phi$）
和4个扩展符号(+、-、\&、$\wedge$)来表示：
\begin{itemize}
	\item $+(l)$	表示以当前位置为起点，在当前方向上前进$l$单位个长度
	\item $!(r)$	表示设置当前节点半径为$r$
	\item $\&(\theta)$	表示设置父子枝夹角为$\theta$
	\item $\wedge(\phi)$	设置水平偏角为$\phi$
\end{itemize}
在球面海龟几何中，将每个骨架节点生成一条参数化的L-System规则，形如：\\
\begin{equation} \label{eq:turtle}
N(l,r) \rightarrow \&(\theta_0)\wedge(\phi_0)!(r) + (l)S_0(l*a_0,r*b_0)...\&(\theta_n)\wedge(\phi_n)!(r) + (l)S_n(l*a_n,r*b_n)
\end{equation}

其中N表示当前枝条，$S_0~S_n$表示当前枝条的n个子枝条，$a_i和b_i$分别表示第i个子枝条
与当前枝条的长度比和半径比，$\theta_i和\phi_i$分别表示第i个子枝条与当前枝条的空间
夹角和水平偏角。

\subsubsection{使用L-System进行树木轻量化建模遇到的问题}
在用参数化L-System进行树木轻量化建模时，在进行规则归纳时，有个难以克服的问题。考虑
将规则\ref{eq:turtle}中的$a_0$换成$a_0'$，则规则变成一个完全不同的规则。这意味着对于
两个分支规则，这两个规则中的子枝的长度，半径，转交，偏角等必须完全相等才能归纳为同
一个规则。而对于自然界中形态结构复杂的树木，每个分支规则几乎不可能完全等同于另一个
规则。

对上面的问题有一种解决方法就是将参数区间化，将属于同一区间的参数的值视为相同。比如
我们可以将父子枝间的转角分为18个区间，每个区间的大小为10度。但是经过分析就可以察觉，
这并没有从根本上解决这个问题。假设我们将这4个变量都各自划分为10个区间，那么规则总数
最多可以有10000个，而且在这种情况下，两个规律相同的几率也是非常小的。如果我们将分区
数量减少，则又有可能将本来差异比较大的规则归纳为一个规则，不符合真实感的要求。

所以，经过分析，这种用参数化L-System进行树木轻量化建模的方法并不适用于从骨架中去抽取
规则，而是适用于反向地用其描述的规则去产生一棵树。

\subsection{树木轻量化？枝干合并！}
\label{subsec:branchmerge}
用L-System的方法抽取规则所产生的问题，从本质上看，是由于自然界中的树木形态太复杂和多变。
与其从一个本就不规则生长的事物中去抽取规则，还不如直接地在其逻辑结构上进行一系列的轻量
化操作。本文提出了对已抽取的树木骨架中对视觉影响不大的部分进行合并的方法，从而在尽可能
保证模型的视觉效果的基础上，进一步地减小树木模型的体积，使得其能更广泛地应用到WebVR、WebGame
等各个领域。

如图所示。。。。进行图片阐述。。。。

伪代码。。。\\
功能：根据纵向合并角度参数，以当前节点为发起点递归式地纵向合并枝干\\
\begin{algorithm}
	\caption{纵向合并枝干}
	\begin{algorithmic}[1]
		%\Comment {根据纵向合并角度参数，以当前节点为发起点递归式地纵向合并枝干}
		\Require 纵向合并角度$\alpha$
		\Require 当前节点$N$
		\Ensure None
		\ForAll{节点$N'\in N.Children$}
		\While{$N'.ChildCount = 1$}
		\State $\vec{u} \gets N'.Position-N.Position$
		\State $\vec{v} \gets N''.Position-N'.Position$
		\State $\gamma \gets \cos^{-1}({\frac{\vec{u} \cdot \vec{v}}{|\vec{u}|\cdot|\vec{v}|}})$
		\If{$\gamma<\alpha$}
		\State $N.child \gets N.AddChild(N'')$
		\State $N.child \gets N.DeleteChild(N') $
		\EndIf
		\State $N' \gets N'.FirstChild$
		\EndWhile
		\EndFor
		\If{$N.ChildCount > 1$}
		\ForAll{节点$N'\in N.Children$}
		\State 以$N'$为当前节点递归调用该函数
		\EndFor
		\EndIf
	\end{algorithmic}
\end{algorithm}

功能：根据横向合并角度参数，横向合并夹角小于角度阈值的末端叶子枝干\\
\begin{algorithm}
	\caption{横向合并枝干}
\begin{algorithmic}[1]
	\Require 初始化横向合并角度$\beta$
	\Require 设定当前节点$N$
	\Ensure None
	\ForAll{节点对$P\in N.Children$}
		\State $N_1 \gets P.FirstNode$
		\State $N_2 \gets P.SecondNode$
		\If{$N_1.ChildCount = 0 \wedge N_2.ChildCount = 0$}
			\State $\vec{u} \gets N_1.Position - N.Position$
			\State $\vec{v} \gets N_2.Position - N.Position$
			\State $\gamma \gets \cos^{-1}({\frac{\vec{u} \cdot \vec{v}}{|\vec{u}|\cdot|\vec{v}|}})$
			\If{$\gamma<\beta$}
				\State $New\ Node\ N'$
				\State $N'.Position \gets (N_1.Position+N_2.Position)/2$
				\State $N'.Radius \gets max(N_1.Radius,N_2.Radius)$
				\State $N.child \gets N.DeleteChild(N_1)$
				\State $N.child \gets N.DeleteChild(N_2)$
				\State $N.child \gets N.AddChild(N')$
				\State 退出循环并以当前节点N重新调用该函数
			\EndIf
		\EndIf
	\EndFor
	\ForAll{节点$P\in N.Children$}
		\State 以P为当前节点递归调用该函数
	\EndFor
\end{algorithmic}
\end{algorithm}

%---------------------------------质量评估----------------------------------
\section{建模质量评估算法}
\label{sec:qualityevaluation}
分步来：
1. 图片序列信息量
2. 三维重建质量
3. 骨架抽取质量

\section{本章小节}
\label{sec:conclusion}
